<?php
/**
 * HELOstore
 *
 * This source file is part of a commercial software. Only users who have purchased a valid license through
 * https://helostore.com/ and accepted to the terms of the License Agreement can install this product.
 *
 * @category   Add-ons
 * @package    HELOstore
 * @copyright  Copyright (c) 2015-2016 HELOstore. (https://helostore.com/)
 * @license    https://helostore.com/legal/license-agreement/   License Agreement
 * @version    $Id$
 */
namespace HeloStore\Developer;

use Tygh\Registry;

class Creator extends Singleton
{
	protected $type;

	protected $version;

	protected $sourcePath;

	public function __construct()
	{
        $this->setType('addon');
        $this->setVersion('latest');
        $this->setSourcePath(
            DEVELOPER_PATH
            . DIRECTORY_SEPARATOR . 'templates'
            . DIRECTORY_SEPARATOR . $this->getType()
            . DIRECTORY_SEPARATOR . $this->getVersion()
        );
	}

    public function prepareData($data = array())
    {
        $defaultData = array(
            'id' => 'demo',
            'version' => '0.1',
            'name' => 'Demo add-on',
            'description' => 'This is a demo add-on generated by Developer Tools',
            'priority' => '1010111',
            'position' => '0',
            'status' => 'disabled',
            'has_icon' => 'Y',
            'default_language' => 'en',
            'company_name' => 'HELOstore',
            'company_email' => 'support@helostore.com',
            'company_url' => 'https://helostore.com/',
            'company_license_url' => 'https://helostore.com/legal/license-agreement/',
            'year' => date('Y'),
            'vendor_name' => 'HeloStore',
            'project_name' => 'demo',

        );

        $data = $data + $defaultData;

        return $data;
    }


    public function validateData(&$data)
    {
        $addon = $data['id'];
        $path = Registry::get('config.dir.addons') . $addon;
        $data['id'] = trim($data['id']);
        $data['id'] = strtolower($data['id']);

        if (empty($data['id'])) {
            $this->addError('You must specify a valid add-on ID.');
            return false;
        }

        if (empty($data['name'])) {
            $this->addError('You must specify a valid add-on name.');
            return false;
        }
        
        if (is_dir($path)) {
            $this->addError('An add-on with the specified ID (' . $data['id'] . ') already exists.');
            return false;
        }

        return true;
    }

    public function getWorkspacePath()
    {
        $tmpPath = Registry::get('config.dir.cache_misc');
        return $tmpPath . 'developer' . DIRECTORY_SEPARATOR . $this->getType() . DIRECTORY_SEPARATOR;
    }

    /**
     * Generate new add-on's files structure based on a template (in a temp dir), making the necessary replacements
     *
     * @param $data
     * @param array $params
     * @return array
     * @throws \Exception
     */
    public function make($data, $params = array())
    {
        $data['composer_hash'] = md5(time());

        $replacements = array();
        $tag = '%';
        foreach ($data as $k => $v) {
            $kSimple = $tag . strtoupper($k) . $tag;
            $replacements[$kSimple] = $v;

            $kUppercase = $tag . strtoupper($k) . '_UPPERCASE' . $tag;
            $replacements[$kUppercase] = mb_strtoupper($v);

            $kLowercase = $tag . strtoupper($k) . '_LOWERCASE' . $tag;
            $replacements[$kLowercase] = mb_strtolower($v);
        }


        $workspacePath = $this->getWorkspacePath();
        fn_rm($workspacePath);
        fn_mkdir($workspacePath);

        $sourcePathRoot = $this->getSourcePath();
        $sourcePaths = fn_get_dir_contents($sourcePathRoot, $getDirs = true, $getFiles = true, $extension = '', $prefix = '', $recursive = true, $exclude = array());

        $destinationPaths = array();

        foreach ($sourcePaths as $sourcePath) {
            $sourcePathAbs = $sourcePathRoot . DIRECTORY_SEPARATOR . $sourcePath;
            $destinationPath = strtr($sourcePath, $replacements);
            $destinationPathAbs = $workspacePath . $destinationPath;

            if (is_file($sourcePathAbs)) {
                $content = file_get_contents($sourcePathAbs);
                if ($content === false) {
                    throw new \Exception('Cannot read: `' . $sourcePathAbs . '`');
                }
                $content = strtr($content, $replacements);
                $bytes = file_put_contents($destinationPathAbs, $content);
                if (empty($bytes)) {
                    throw new \Exception('Cannot write: `' . $destinationPathAbs . '`');
                }
            } else if (is_dir($sourcePathAbs)) {
                fn_mkdir($destinationPathAbs);
                if (!is_dir($destinationPathAbs)) {
                    throw new \Exception('Cannot create: `' . $destinationPathAbs . '`');
                }
            } else {

            }
            $destinationPaths[] = !empty($params['absolutePaths']) ? $destinationPathAbs : $destinationPath;
        }

        $this->addResult('make', array(
            'destinationPaths' => $destinationPaths,
            'addon' => $data,
            'workspacePath' => $workspacePath
        ));

        return $destinationPaths;
    }

    /**
     * Archives the add-on
     *
     * @param $paths
     * @param $data
     * @return array|bool
     */
    public function archive($paths, $data)
    {
        $workspacePath =  $this->getWorkspacePath();

        $filename = $data['id'] . '-v' . $data['version'] . '.zip';

        $exclusions = array();
        $excluded = array();
        $included = array();

        $downloadUrl = $this->getDownloadUrl();
        $archiveUrl = $downloadUrl . $filename;
        $archivePath = $this->getArchivePath() . DIRECTORY_SEPARATOR . $filename;

        $releaseManager = ReleaseManager::instance();
        if ($releaseManager->archive($paths, $archivePath, $workspacePath, $exclusions, $excluded, $included)) {
            $result = true;

            $this->addResult('archive', array(
                'filename' => $filename,
                'path' => $archivePath,
                'url' => $archiveUrl,
                'includedFiles' => $included,
                'excludedFiles' => $excluded,
            ));

        } else {
            $result = false;
            $this->addErrors($releaseManager->getErrors());
            $this->addError('Failed archiving `' . $archivePath . '`.');
        }

        return $result;
    }

    public function getArchivePath()
    {
        return dirname($this->getWorkspacePath());
    }

    public function getDownloadUrl($absolute = true)
    {
        $archivePath = $this->getArchivePath();
        $rootPath = Registry::get('config.dir.root');
        $relativeArchivePath = str_replace($rootPath, '', $archivePath);
        $relativeArchivePath .= '/';
        $baseUrl = Registry::get('config.http_location');
        if ($absolute) {
            return $baseUrl . $relativeArchivePath;
        } else {
            return $relativeArchivePath;
        }
    }


    /**
     * Installs the add-on from its temporary path
     */
    public function install()
    {
        $workspace = $this->getWorkspacePath();
        return fn_addons_move_and_install($workspace, Registry::get('config.dir.root'));
    }

    /**
     * @param array $data
     * @return array
     */
    public function getFields($data = array())
    {
        $options = array();
        $options['general'] = array();
        $options['general'][] = array(
            'name' => 'post_actions',
            'description' => __('developer.generate.post_actions'),
            'type' => 'H'
        );

        $options['general'][] = array(
            'name' => 'install',
            'description' => __('developer.generate.addon.install'),
            'tooltip' => __('developer.generate.addon.install.tooltip'),
            'type' => 'C',
            'value' => (!empty($data) && $data['install'] == 'Y' ? 'Y' : 'N')
        );
        $options['general'][] = array(
            'name' => 'archive',
            'description' => __('developer.generate.addon.archive'),
            'type' => 'C',
            'value' => (!empty($data) && $data['archive'] == 'Y' ? 'Y' : 'N')
        );

        $options['general'][] = array(
            'name' => 'settings',
            'description' => __('developer.generate.addon.settings'),
            'type' => 'H'
        );

        $data = $this->prepareData($data);

        foreach ($data as $field => $value) {
            if (in_array($field, array('install', 'archive'))) {
                continue;
            }
            $langVar = 'developer.generate.addon.' . $field;
            $tooltip = __($langVar . '.tooltip');
            if (substr($tooltip, 0, 1) == '_') {
                $tooltip = false;
            }
            $type = 'I';
            if (in_array($field, array('has_icon'))) {
                $type = 'C';
            }
            $options['general'][] = array(
                'name' => $field,
                'description' => __($langVar),
                'value' => $value,
                'type' => $type,
                'tooltip' => $tooltip
            );
        }

        return $options;
    }

	/**
	 * @return mixed
	 */
	public function getVersion()
	{
		return $this->version;
	}

	/**
	 * @param mixed $version
	 */
	public function setVersion($version)
	{
		$this->version = $version;
	}


	/**
	 * @return mixed
	 */
	public function getSourcePath()
	{
		return $this->sourcePath;
	}

	/**
	 * @param mixed $sourcePath
	 */
	public function setSourcePath($sourcePath)
	{
		$this->sourcePath = $sourcePath;
	}

	/**
	 * @return mixed
	 */
	public function getType()
	{
		return $this->type;
	}

	/**
	 * @param mixed $type
	 */
	public function setType($type)
	{
		$this->type = $type;
	}
}